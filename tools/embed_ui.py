#!/usr/bin/env python3
"""
PlatformIO pre-build script to embed web UI files into firmware.
Run automatically by PlatformIO before compilation.

This script:
1. Reads HTML/CSS/JS from data/ui/
2. Gzips each file for smaller size
3. Converts to C byte arrays
4. Writes to include/embedded_ui.h
"""

import os
import gzip

# PlatformIO integration
Import("env")

# Get project directory
PROJECT_DIR = env.get("PROJECT_DIR", os.getcwd())

# Paths relative to project root
UI_DIR = os.path.join(PROJECT_DIR, "data", "ui")
INCLUDE_DIR = os.path.join(PROJECT_DIR, "include")
OUTPUT_FILE = os.path.join(INCLUDE_DIR, "embedded_ui.h")

# Files to embed (in order)
UI_FILES = [
    ("index.html", "text/html"),
    ("styles.css", "text/css"),
    ("script.js", "application/javascript"),
]

def gzip_content(content):
    """Gzip compress content."""
    return gzip.compress(content, compresslevel=9)

def bytes_to_c_array(data, var_name):
    """Convert bytes to C array declaration."""
    lines = []
    lines.append(f"const uint8_t {var_name}[] PROGMEM = {{")
    
    # Format bytes, 16 per line
    hex_values = [f"0x{b:02X}" for b in data]
    for i in range(0, len(hex_values), 16):
        chunk = hex_values[i:i+16]
        lines.append("    " + ", ".join(chunk) + ",")
    
    lines.append("};")
    lines.append(f"const size_t {var_name}_len = {len(data)};")
    return "\n".join(lines)

def generate_header():
    """Generate the embedded_ui.h header file."""
    
    # Check if UI directory exists
    if not os.path.isdir(UI_DIR):
        print(f"[embed_ui] Warning: {UI_DIR} directory not found, using fallback UI")
        return generate_fallback_header()
    
    header_parts = [
        "// AUTO-GENERATED FILE - DO NOT EDIT",
        "// Generated by tools/embed_ui.py",
        "#pragma once",
        "#include <Arduino.h>",
        "",
    ]
    
    file_info = []
    
    for filename, content_type in UI_FILES:
        filepath = os.path.join(UI_DIR, filename)
        
        if not os.path.isfile(filepath):
            print(f"[embed_ui] Warning: {filepath} not found, skipping")
            continue
        
        # Read and compress
        with open(filepath, 'rb') as f:
            original = f.read()
        
        compressed = gzip_content(original)
        
        # Generate variable name
        var_name = filename.replace('.', '_').replace('-', '_').upper() + "_GZ"
        
        print(f"[embed_ui] {filename}: {len(original)} bytes -> {len(compressed)} bytes (gzipped)")
        
        # Generate C array
        header_parts.append(f"// {filename} - {len(original)} bytes original, {len(compressed)} bytes gzipped")
        header_parts.append(bytes_to_c_array(compressed, var_name))
        header_parts.append("")
        
        file_info.append({
            "filename": filename,
            "var_name": var_name,
            "content_type": content_type,
            "original_size": len(original),
            "compressed_size": len(compressed),
        })
    
    # Generate file info struct
    header_parts.append("// Embedded file info")
    header_parts.append("struct EmbeddedFile {")
    header_parts.append("    const char* filename;")
    header_parts.append("    const char* contentType;")
    header_parts.append("    const uint8_t* data;")
    header_parts.append("    size_t length;")
    header_parts.append("};")
    header_parts.append("")
    
    header_parts.append("const EmbeddedFile EMBEDDED_FILES[] = {")
    for info in file_info:
        header_parts.append(f'    {{"{info["filename"]}", "{info["content_type"]}", {info["var_name"]}, {info["var_name"]}_len}},')
    header_parts.append("};")
    header_parts.append(f"const size_t EMBEDDED_FILES_COUNT = {len(file_info)};")
    header_parts.append("")
    
    # Add helper function declaration
    header_parts.append("// Helper to find embedded file by name")
    header_parts.append("inline const EmbeddedFile* findEmbeddedFile(const char* filename) {")
    header_parts.append("    for (size_t i = 0; i < EMBEDDED_FILES_COUNT; i++) {")
    header_parts.append("        if (strcmp(EMBEDDED_FILES[i].filename, filename) == 0) {")
    header_parts.append("            return &EMBEDDED_FILES[i];")
    header_parts.append("        }")
    header_parts.append("    }")
    header_parts.append("    return nullptr;")
    header_parts.append("}")
    
    return "\n".join(header_parts)

def generate_fallback_header():
    """Generate a minimal fallback header when no UI files exist."""
    return """// AUTO-GENERATED FILE - DO NOT EDIT
// Fallback header - no UI files found
#pragma once
#include <Arduino.h>

struct EmbeddedFile {
    const char* filename;
    const char* contentType;
    const uint8_t* data;
    size_t length;
};

const EmbeddedFile EMBEDDED_FILES[] = {};
const size_t EMBEDDED_FILES_COUNT = 0;

inline const EmbeddedFile* findEmbeddedFile(const char* filename) {
    return nullptr;
}
"""

def embed_ui_files(source, target, env):
    """PlatformIO build callback to embed UI files."""
    print("[embed_ui] Embedding UI files into firmware...")
    
    # Ensure include directory exists
    os.makedirs(INCLUDE_DIR, exist_ok=True)
    
    header_content = generate_header()
    
    with open(OUTPUT_FILE, 'w') as f:
        f.write(header_content)
    
    print(f"[embed_ui] Generated {OUTPUT_FILE}")

# Register the pre-build action
env.AddPreAction("buildprog", embed_ui_files)

# Also run immediately for the first build
print("[embed_ui] Running pre-build UI embedding...")
os.makedirs(INCLUDE_DIR, exist_ok=True)
header_content = generate_header()
with open(OUTPUT_FILE, 'w') as f:
    f.write(header_content)
print(f"[embed_ui] Generated {OUTPUT_FILE}")
